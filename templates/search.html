{% extends "base.html" %}

{% block title %}{{ t('search.title') }} - {{ site_title }}{% endblock %}

{% block content %}
<div class="mb-6">
    <h2 class="font-bold">{{ t('search.title') }}</h2>
</div>

<div x-data="searchApp()">
    <!-- Search Input -->
    <div class="mb-6">
        <div class="search-wrapper">
            <input
                type="text"
                x-model="searchQuery"
                @input.debounce.300ms="performSearch()"
                placeholder="{{ t('search.placeholder') }}"
                class="search-input">
            <svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
            </svg>
        </div>
        <p class="text-sm text-muted mt-2">
            {{ t('search.across', count=passages|length) }}
        </p>
    </div>

    <!-- No Query State -->
    <div x-show="!searchQuery" class="text-center py-8 text-muted">
        <p>Enter a search term to find matching sentences.</p>
    </div>

    <!-- Search Results -->
    <div x-show="searchQuery" x-html="resultsHtml"></div>
</div>

<!-- Passage URL mapping -->
<script id="passage-urls" type="application/json">
{
    {% for p in passage_list %}
    "{{ p.index }}": "{{ base_url }}passages/{{ p.slug }}/"{% if not loop.last %},{% endif %}
    {% endfor %}
}
</script>

<!-- Passages data for search -->
<script id="passages-json" type="application/json">
{{ passages_json | safe }}
</script>
{% endblock %}

{% block scripts %}
<script>
function searchApp() {
    return {
        searchQuery: '',
        passages: [],
        passageUrls: {},
        resultsHtml: '',
        searchId: 0,

        init() {
            const jsonEl = document.getElementById('passages-json');
            if (jsonEl) {
                try {
                    const data = JSON.parse(jsonEl.textContent);
                    this.passages = data.passages || [];
                } catch (e) {
                    console.error('Failed to parse passages JSON:', e);
                }
            }
            const urlsEl = document.getElementById('passage-urls');
            if (urlsEl) {
                try {
                    this.passageUrls = JSON.parse(urlsEl.textContent);
                } catch (e) {
                    console.error('Failed to parse passage URLs:', e);
                }
            }
        },

        async performSearch() {
            const query = this.searchQuery.trim().toLowerCase();
            const currentSearchId = ++this.searchId;

            if (!query) {
                this.resultsHtml = '';
                return;
            }

            const results = [];
            for (let passageIndex = 0; passageIndex < this.passages.length; passageIndex++) {
                // Check for cancellation
                if (currentSearchId !== this.searchId) return;

                const passage = this.passages[passageIndex];
                const matchingSentences = [];
                let sentenceNum = 0;
                (passage.sentences || []).forEach((sentence) => {
                    if (!sentence.word_tracks?.[0]?.words?.length) return;
                    sentenceNum++;  // Only count valid sentences (matches passage.html filtering)
                    let matches = false;
                    sentence.word_tracks.forEach(track => {
                        (track.words || []).forEach(word => {
                            if (word && word.toLowerCase().includes(query)) matches = true;
                        });
                    });
                    (sentence.sentence_tracks || []).forEach(track => {
                        if (track.sentence?.toLowerCase().includes(query)) matches = true;
                    });
                    if (matches) matchingSentences.push({ sentence, sentenceNum });
                });
                if (matchingSentences.length > 0) {
                    results.push({ passage, passageIndex, matchingSentences });
                }

                // Cooperative yield after each passage
                await new Promise(r => setTimeout(r, 0));
            }

            // Final cancellation check before rendering
            if (currentSearchId !== this.searchId) return;

            this.resultsHtml = this.renderResults(results, query);
        },

        renderResults(results, query) {
            if (results.length === 0) {
                return `<div class="text-center py-8 text-muted">
                    <p>No results found for "${this.escapeHtml(query)}"</p>
                </div>`;
            }

            return results.map(result => {
                const url = this.passageUrls[result.passageIndex] || '#';
                return `
                <div class="result-card">
                    <div class="result-header">
                        <div>
                            <h3>${this.escapeHtml(result.passage.name)}</h3>
                            <p class="text-xs text-muted">${result.matchingSentences.length} matching sentence(s)</p>
                        </div>
                        <a href="${url}" class="text-sm">View full passage &rarr;</a>
                    </div>
                    <div class="result-body space-y-4">
                        ${result.matchingSentences.slice(0, 5).map(s => this.renderSentence(s.sentence, s.sentenceNum, url, query)).join('')}
                        ${result.matchingSentences.length > 5 ? `<p class="text-sm text-muted">... and ${result.matchingSentences.length - 5} more</p>` : ''}
                    </div>
                </div>`;
            }).join('');
        },

        renderSentence(sentence, sentenceNum, passageUrl, query) {
            const wordCount = sentence.word_tracks[0].words.length;
            let cls = '';
            if (!sentence.grammatical) cls += ' ungrammatical';
            if (sentence.infelicitous) cls += ' infelicitous';

            const sentenceUrl = `${passageUrl}#sentence-${sentenceNum}`;
            let html = `<div class="result-sentence${cls}">`;
            html += `<div class="sentence-number"><a href="${sentenceUrl}">(${sentenceNum})</a></div>`;
            html += `<div class="interlinear-grid">`;
            for (let i = 0; i < wordCount; i++) {
                html += '<div class="word-column">';
                for (const track of sentence.word_tracks) {
                    const word = track.words[i] || '';
                    const isIPA = track.name === 'IPA' || track.name === 'Phonetic';
                    const highlighted = this.highlight(word, query);
                    html += `<span class="${isIPA ? 'ipa-text' : 'gloss-text'}">${highlighted}</span>`;
                }
                html += '</div>';
            }
            html += '</div>';
            (sentence.sentence_tracks || []).forEach(track => {
                html += `<div class="translation">${this.highlight(track.sentence, query)}</div>`;
            });
            html += '</div>';
            return html;
        },

        highlight(text, query) {
            if (!text) return '';
            const escaped = this.escapeHtml(text).replace(/\^\{([^}]*)\}/g, '<sup>$1</sup>');
            const idx = escaped.toLowerCase().indexOf(query.toLowerCase());
            if (idx === -1) return escaped;
            return escaped.slice(0, idx) + '<mark class="search-highlight">' + escaped.slice(idx, idx + query.length) + '</mark>' + escaped.slice(idx + query.length);
        },

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
    };
}
</script>
{% endblock %}
